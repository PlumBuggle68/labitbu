<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>labitbu.com üëπ</title>

  <style>
    body { font-family: system-ui, sans-serif; margin: 0; line-height: 1.4; }
    #labitbu-container { max-width: 720px; margin: 40px auto; padding: 0 1rem; }
    button {
      background-color: #007bff;
      color: #fff;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin: 5px;
    }
    button:hover { background-color: #0056b3; }

    button:disabled {
      background-color: #6c757d !important;
      cursor: default;
      opacity: .55;
    }
    #deposit-btn:not(:disabled),
    #mint-btn:not(:disabled) {
      background-color: #28a745 !important;
    }

    #destination-address {
      width: 100%; padding: 10px; font-size: 16px;
      border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box;
      margin-top: .5rem;
    }
    #address-error { height: 1em; margin-top: .5rem; }
  </style>
</head>
<body>
  <div id="labitbu-container">
    <h1 style="text-align:center;color:#333;">labitbu.com üëπ</h1>

    <div style="text-align:center;margin-bottom:2rem;">
      <a class="github-button" href="https://github.com/stutxo/labitbu"
         data-show-count="true" aria-label="Star stutxo/labitbu on GitHub">Star</a>
    </div>

    <p style="text-align:center;color:#333;">Check the github to see how it works, everything is done locally in the browser and uses your xverse pubkey to create the deposit address</p>
    
    <p style="text-align:center;margin:2rem 0">
      <button id="connect-btn">Connect Xverse</button>
    </p>

    <p style="text-align:center;color:#333;" id="deposit-address"></p>

    <p id="deposit-area" style="text-align:center;margin-top:2rem;">
      <button id="deposit-btn" disabled>Deposit 5&nbsp;000 sats</button>
    </p>

    <div id="destination-section" style="display:none;text-align:center;margin-bottom:2rem;">
      <label style="font-weight:bold;">Destination Address</label><br>
      <label style="font-weight:bold;color:red;">
        ‚ö†Ô∏è Use a wallet with full UTXO control (Ordinals-safe)
      </label><br>
      <small style="color:#555;">
        Transfers follow ordinal theory; wallet must honour <strong>FIFO</strong>.
      </small><br>
      <input id="destination-address" type="text" placeholder="bc1p‚Ä¶ Taproot address" />
      <p id="address-error" style="color:red;"></p>

      <button id="mint-btn" disabled>Mint Labitbu</button>
    </div>

    <div id="display-labitbu" style="text-align:center;margin-top:2rem;"></div>
  </div>

  <script async defer src="https://buttons.github.io/buttons.js"></script>
  <script src="https://mempool.space/mempool.js"></script>
  <script src="labitbu-generator.js"></script>

  <script type="module">
    import { request, AddressPurpose, RpcErrorCode } from 'https://esm.sh/sats-connect';
    import initWasm, { create_deposit_address, mint } from './pkg/labitbu.js';
    import mempoolJS from 'https://esm.sh/@mempool/mempool.js';
    import { Buffer } from 'https://esm.sh/buffer';

    const generator     = new LabitbuGenerator();
    const { labitbus, accessories } = await (await fetch('/labitbu-traits.json')).json();
    generator.setLabitbus(Object.values(labitbus));
    generator.setAccessories(Object.values(accessories));
    await initWasm();

    const { bitcoin:{ addresses, transactions, fees } } = mempoolJS({ hostname:'mempool.space' });

    const $connectBtn  = document.getElementById('connect-btn');
    const $depositBtn  = document.getElementById('deposit-btn');
    const $mintBtn     = document.getElementById('mint-btn');
    const destInput    = document.getElementById('destination-address');
    const addrElem    = document.getElementById('deposit-address');
    const errElem      = document.getElementById('address-error');

    let walletPaymentAddress = null;
    let validDestinationAddress = null;
    let currentPubkey = null;
    let currentByteArray = null;
    let generatedDepositAddress = null;
    let depositMade = false;
    let cachedUtxos = null;

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    function setDepositAddressText() {
      addrElem.textContent = generatedDepositAddress ? `Labitbu address: ${generatedDepositAddress}` : '';
    }

    function maybeEnableDeposit() {
      if (currentPubkey && currentByteArray && !depositMade) $depositBtn.disabled = false;
      else $depositBtn.disabled = true;
    }
    function maybeEnableMint() {
      if (depositMade && cachedUtxos?.length && validDestinationAddress) $mintBtn.disabled = false;
      else $mintBtn.disabled = true;
    }

    async function waitForUtxo(addr) {
      while (true) {
        const utxos = await addresses.getAddressTxsUtxo({ address: addr });
        if (utxos.length) return utxos;
        await sleep(2000);
      }
    }

    async function refreshState() {
      if (!generatedDepositAddress) return;
      const utxos = await addresses.getAddressTxsUtxo({ address: generatedDepositAddress });
      if (utxos.length) {
        depositMade  = true;
        cachedUtxos  = utxos;
        document.getElementById('destination-section').style.display = 'block';
      } else {
        depositMade  = false;
        cachedUtxos  = null;
        document.getElementById('destination-section').style.display = 'none';
      }
      maybeEnableDeposit();
      maybeEnableMint();
    }

    $connectBtn.onclick = async () => {
      try {
        const resp = await request('wallet_connect', null);
        if (resp.status !== 'success') throw resp.error || new Error('connect failed');

        const pay = resp.result.addresses.find(a => a.purpose === AddressPurpose.Payment);
        if (!pay) return alert('No payment address returned by wallet');

        walletPaymentAddress          = pay.address;
        currentPubkey                 = pay.publicKey.slice(2);
        $connectBtn.textContent       = 'Xverse Connected';
        $connectBtn.disabled          = true;
        $connectBtn.style.background  = '#6c757d';

        const { bytes:padded } = await generateLabitbu(currentPubkey);
        currentByteArray       = new Uint8Array(padded);

        generatedDepositAddress = new TextDecoder().decode(
          create_deposit_address(currentPubkey, currentByteArray)
        );
        setDepositAddressText();
        await refreshState();
      } catch (e) {
        console.error(e);
        alert(e.message || 'Wallet connect failed');
      }
    };

    $depositBtn.onclick = async () => {
      if (depositMade) return;
      $depositBtn.disabled = true;
      const loaderId = startDots($depositBtn);
      try {
        let utxos = await addresses.getAddressTxsUtxo({ address: generatedDepositAddress });
        if (!utxos.length) {
          const send = await request('sendTransfer', {
            recipients:[{ address: generatedDepositAddress, amount:5000, memo:'Labitbu mint' }]
          });
          if (send.status !== 'success') throw new Error(send.error?.message || 'sendTransfer failed');
        }
        $depositBtn.textContent = 'Waiting for utxo deposit‚Ä¶';
        utxos = await waitForUtxo(generatedDepositAddress);

        cachedUtxos  = utxos;
        depositMade  = true;
        $depositBtn.textContent = 'Deposit confirmed';
        document.getElementById('destination-section').style.display = 'block';
        maybeEnableMint();
      } catch (e) {
        console.error(e);
        $depositBtn.disabled = false;
      } finally {
        clearInterval(loaderId);
      }
    };

    $mintBtn.onclick = async () => {
      if (!depositMade || !cachedUtxos?.length) return;
      try {
        const inputs = cachedUtxos.map(u => ({
          previous_output:`${u.txid}:${u.vout}`,
          sequence:0xFFFFFFFD, script_sig:'', witness:[]
        }));
        const prevTxouts = await Promise.all(
          cachedUtxos.map(async ({ txid,vout }) => {
            const out = (await transactions.getTx({ txid })).vout[vout];
            return { value:Number(out.value), script_pubkey:out.scriptpubkey };
          })
        );

        const total = cachedUtxos.reduce((s,u)=>s+BigInt(u.value),0n);
        const { fastestFee } = await fees.getFeesRecommended();
        const vbytes = 1200n;
        const fee    = BigInt(Math.ceil(fastestFee))*vbytes;
        if (fee >= total) { errElem.textContent='Fee ‚â• deposit'; return; }
        if (total-fee < 330n){
          errElem.textContent = `Output would be dust (${total-fee} sats)`; return;
        }

        const psbtB64 = Buffer.from(
          mint(currentPubkey,currentByteArray,total,validDestinationAddress,fee,inputs,prevTxouts)
        ).toString('base64');

        const sign = await request('signPsbt',{
          psbt:psbtB64,
          signInputs:{ [walletPaymentAddress]:[0] },
          broadcast:true
        });
        if (sign.status!=='success') throw new Error(sign.error?.message||'signPsbt failed');

        const { txid } = sign.result;
        const url = `https://mempool.space/tx/${txid}`;

        errElem.style.color = 'green';
        errElem.innerHTML = `<a href="${url}" target="_blank" rel="noopener">${url}</a>`;

        $mintBtn.disabled = true;
      } catch(e){
        console.error(e);
        errElem.style.color='red';
        errElem.textContent = e.message || 'Unknown error';
      }
    };

    destInput.addEventListener('input', () => {
      errElem.textContent='';
      validDestinationAddress=null;
      maybeEnableMint();

      const addr = destInput.value.trim();
      if (!addr.startsWith('bc1p')) { errElem.textContent='Must start bc1p'; return; }
      if (addr.length!==62)         { errElem.textContent='Must be 62 chars'; return; }

      validDestinationAddress = addr;
      maybeEnableMint();
    });

    async function generateLabitbu(xonlyPubkey) {
      const view = document.getElementById('display-labitbu');
      view.innerHTML='';
      try {
        const res   = await generator.generate(xonlyPubkey);
        const blob  = new Blob([res.unpaddedBytes],{ type:res.format });
        const img   = new Image();
        img.src     = URL.createObjectURL(blob);
        view.appendChild(img);
        const p     = document.createElement('p');
        p.textContent=`Image: ${res.unpaddedBytes.length} bytes`;
        view.appendChild(p);
        return res;
      } catch(e){ view.textContent='Error: '+e.message; }
    }

    function startDots(btn, base = 'Waiting for UTXO') {
        let dots = 0;
        const id = setInterval(() => {
            dots = (dots + 1) % 4;
            btn.textContent = base + '.'.repeat(dots);
        }, 350);
        return id;
    }
  </script>
</body>
</html>
